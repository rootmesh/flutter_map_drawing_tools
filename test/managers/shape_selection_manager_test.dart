import 'package:flutter/material.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:flutter_map_drawing_tools/src/managers/shape_selection_manager.dart';
import 'package:flutter_map_drawing_tools/src/models/drawing_state.dart';
import 'package:flutter_map_drawing_tools/src/models/drawing_tools_options.dart';
import 'package:flutter_map_drawing_tools/src/models/shape_data_models.dart';
import 'package:flutter_map/plugin_api.dart'; // For MapTransformer
import 'package:latlong2/latlong.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:flutter_test/flutter_test.dart';

// Generate mocks for these classes
@GenerateMocks([
  DrawingState,
  DrawingToolsOptions,
  MapTransformer,
])
import 'shape_selection_manager_test.mocks.dart'; // This file will be generated by running build_runner

// Helper to create a concrete MapTransformer for tests where its internal logic isn't mocked away.
// However, for most unit tests, we'll use a mocked MapTransformer.
MapTransformer getTestMapTransformer({LatLng center = const LatLng(0,0), double zoom = 13.0}) {
  return MapTransformer(
    mapState: MapState(
      crs: const Epsg3857(), // Standard CRS
      center: center,
      zoom: zoom,
      // other MapState params as needed
    ),
  );
}


void main() {
  late MockDrawingState mockDrawingState;
  late MockDrawingToolsOptions mockOptions;
  late MockMapTransformer mockMapTransformer;
  late ShapeSelectionManager selectionManager;

  setUp(() {
    mockDrawingState = MockDrawingState();
    mockOptions = MockDrawingToolsOptions();
    mockMapTransformer = MockMapTransformer(); // Use the generated mock
    
    // Default stubbing for options
    // Configure selectionHitTolerance if your tests depend on it for polylines/markers
    // For example: when(mockOptions.selectionHitTolerance).thenReturn(15.0);
    // No specific options needed for basic selection logic beyond what ShapeSelectionManager uses internally.

    // Default stubbing for drawingState
    when(mockDrawingState.currentShapes).thenReturn([]);
    when(mockDrawingState.selectedShapeId).thenReturn(null);
    when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(false);

    // Default stubbing for mapTransformer
    // Mock LatLng to pixel conversions. These are crucial for polyline and marker hit testing.
    // Provide a default behavior that simply scales LatLng for simplicity in setup.
    // Specific tests can override this.
    when(mockMapTransformer.latLngToPixel(any, any)).thenAnswer((invocation) {
      final latlng = invocation.positionalArguments[0] as LatLng;
      // Simple scaling, not a real projection, but good enough for relative distance checks in tests.
      return CustomPoint(latlng.longitude * 1000, latlng.latitude * 1000);
    });
     when(mockMapTransformer.centerZoom).thenReturn(MapCamera(center: LatLng(0,0), zoom: 13));


    selectionManager = ShapeSelectionManager(
      drawingState: mockDrawingState,
      options: mockOptions,
    );
  });

  group('Initialization', () {
    test('initializes correctly', () {
      expect(selectionManager, isNotNull);
    });
  });

  group('Tap Handling and Selection/Deselection', () {
    final testPolygon = PolygonShapeData(
      polygon: Polygon(points: [LatLng(0,0), LatLng(0,1), LatLng(1,1), LatLng(1,0), LatLng(0,0)], color: Colors.blue),
      id: "poly1",
      label: "Test Polygon",
    );

    test('selects a shape on tap', () {
      when(mockDrawingState.currentShapes).thenReturn([testPolygon]);
      final tapPos = LatLng(0.5, 0.5); // Inside the polygon

      final result = selectionManager.handleTap(tapPos, mockMapTransformer);

      expect(result, isTrue);
      final captured = verify(mockDrawingState.selectShape(captureAny, captureAny)).captured;
      expect(captured[0], testPolygon.id);
      expect(captured[1], isA<PolygonShapeData>()); // Verifies a copy is passed
      expect((captured[1] as PolygonShapeData).id, testPolygon.id);
    });

    test('deselects a shape when tapping away', () {
      when(mockDrawingState.selectedShapeId).thenReturn("poly1");
      when(mockDrawingState.currentShapes).thenReturn([testPolygon]); // Shape exists but tap is away
      final tapPos = LatLng(2, 2); // Outside the polygon

      final result = selectionManager.handleTap(tapPos, mockMapTransformer);

      expect(result, isTrue);
      verify(mockDrawingState.deselectShape()).called(1);
    });

    test('does nothing if tapping an already selected shape (by default)', () {
      when(mockDrawingState.selectedShapeId).thenReturn("poly1");
      when(mockDrawingState.currentShapes).thenReturn([testPolygon]);
      final tapPos = LatLng(0.5, 0.5); // Inside the polygon

      final result = selectionManager.handleTap(tapPos, mockMapTransformer);
      
      expect(result, isTrue); // True because a shape was hit (the selected one)
      verifyNever(mockDrawingState.deselectShape());
      verifyNever(mockDrawingState.selectShape(any, any)); // Should not re-select
    });
    
    test('returns false if no shape is hit and no shape was selected', () {
      when(mockDrawingState.currentShapes).thenReturn([]); // No shapes
      final tapPos = LatLng(0.5, 0.5);

      final result = selectionManager.handleTap(tapPos, mockMapTransformer);
      expect(result, isFalse);
      verifyNever(mockDrawingState.selectShape(any, any));
      verifyNever(mockDrawingState.deselectShape());
    });

    test('does not select if multi-part drawing is in progress', () {
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(true);
      when(mockDrawingState.currentShapes).thenReturn([testPolygon]);
      final tapPos = LatLng(0.5, 0.5); // Inside the polygon

      final result = selectionManager.handleTap(tapPos, mockMapTransformer);
      expect(result, isFalse);
      verifyNever(mockDrawingState.selectShape(any, any));
    });
  });

  group('Hit-Testing Logic - Polygons', () {
    // A square polygon from (0,0) to (2,2)
    final polygonPoints = [LatLng(0,0), LatLng(0,2), LatLng(2,2), LatLng(2,0), LatLng(0,0)];
    // A hole inside the square from (0.5,0.5) to (1.5,1.5)
    final holePoints = [LatLng(0.5,0.5), LatLng(0.5,1.5), LatLng(1.5,1.5), LatLng(1.5,0.5), LatLng(0.5,0.5)];
    final polygonWithHole = PolygonShapeData(
      polygon: Polygon(points: polygonPoints, holePointsList: [holePoints], color: Colors.blue),
      id: "polyWithHole",
    );

    setUp(() {
      when(mockDrawingState.currentShapes).thenReturn([polygonWithHole]);
    });

    test('tap inside polygon, outside hole', () {
      final tapPos = LatLng(0.25, 0.25); // Inside main, outside hole
      expect(selectionManager.handleTap(tapPos, mockMapTransformer), isTrue);
      verify(mockDrawingState.selectShape(polygonWithHole.id, any)).called(1);
    });

    test('tap inside hole', () {
      final tapPos = LatLng(1, 1); // Inside hole
      expect(selectionManager.handleTap(tapPos, mockMapTransformer), isFalse);
      verifyNever(mockDrawingState.selectShape(any, any));
    });

    test('tap outside polygon', () {
      final tapPos = LatLng(3, 3); // Outside main polygon
      expect(selectionManager.handleTap(tapPos, mockMapTransformer), isFalse);
      verifyNever(mockDrawingState.selectShape(any, any));
    });

    test('tap on polygon border', () {
      final tapPos = LatLng(0, 1); // On the border
      expect(selectionManager.handleTap(tapPos, mockMapTransformer), isTrue);
      verify(mockDrawingState.selectShape(polygonWithHole.id, any)).called(1);
    });
     test('tap on hole border', () {
      final tapPos = LatLng(0.5, 1); // On the hole border
      expect(selectionManager.handleTap(tapPos, mockMapTransformer), isFalse); // Still considered inside the hole
      verifyNever(mockDrawingState.selectShape(any, any));
    });
  });

  group('Hit-Testing Logic - Polylines', () {
    // Polyline from (0,0) to (2,2)
    final polyline = PolylineShapeData(
      polyline: Polyline(points: [LatLng(0,0), LatLng(2,2)], strokeWidth: 5),
      id: "line1",
    );

    setUp(() {
      when(mockDrawingState.currentShapes).thenReturn([polyline]);
      // Mock transformer for precise pixel distance checks
      // Point (0,0) -> (0,0)px, (1,1) -> (100,100)px, (2,2) -> (200,200)px
      when(mockMapTransformer.latLngToPixel(LatLng(0,0), any)).thenReturn(CustomPoint(0.0, 0.0));
      when(mockMapTransformer.latLngToPixel(LatLng(1,1), any)).thenReturn(CustomPoint(100.0, 100.0));
      when(mockMapTransformer.latLngToPixel(LatLng(2,2), any)).thenReturn(CustomPoint(200.0, 200.0));
    });

    test('tap near polyline segment', () {
      // Tap at (0.9, 0.9) -> (90,90)px. Distance to segment (0,0)-(200,200) should be small.
      // The segment is y=x. Point (90,90) is on the line. Distance will be 0.
      // The internal threshold is polylineWidth/2 + _kPolylineHitThreshold (default 15).
      // So, 5/2 + 15 = 17.5. A distance of 0 is well within this.
      when(mockMapTransformer.latLngToPixel(LatLng(0.9,0.9), any)).thenReturn(CustomPoint(90.0, 90.0));
      expect(selectionManager.handleTap(LatLng(0.9,0.9), mockMapTransformer), isTrue);
      verify(mockDrawingState.selectShape(polyline.id, any)).called(1);
    });

    test('tap far from polyline segment', () {
      // Tap at (0,2) -> (0,200)px. Distance to segment (0,0)-(200,200) is sqrt(20000) approx 141.
      when(mockMapTransformer.latLngToPixel(LatLng(0,2), any)).thenReturn(CustomPoint(0.0, 200.0));
      expect(selectionManager.handleTap(LatLng(0,2), mockMapTransformer), isFalse);
      verifyNever(mockDrawingState.selectShape(any, any));
    });
  });

  group('Hit-Testing Logic - Circles', () {
    // Circle centered at (0,0) with radius 100 meters
    final circle = CircleShapeData(
      circleMarker: CircleMarker(point: LatLng(0,0), radius: 100, useRadiusInMeter: true, color: Colors.red),
      id: "circle1",
    );
    setUp(() {
      when(mockDrawingState.currentShapes).thenReturn([circle]);
    });

    test('tap inside circle', () {
      // Tap at (0.0001, 0.0001) is very close to center, well within 100m
      final tapPos = LatLng(0.0001, 0.0001); 
      expect(selectionManager.handleTap(tapPos, mockMapTransformer), isTrue);
      verify(mockDrawingState.selectShape(circle.id, any)).called(1);
    });

    test('tap outside circle', () {
      // Tap at (1,1) is far from (0,0) > 100m
      final tapPos = LatLng(1,1); 
      expect(selectionManager.handleTap(tapPos, mockMapTransformer), isFalse);
      verifyNever(mockDrawingState.selectShape(any, any));
    });
    
    test('tap on circle circumference (approx)', () {
      // Approx 100m East of (0,0)
      final tapPos = const Distance(meters: 100).offset(LatLng(0,0), 90); // 90 degrees = East
      expect(selectionManager.handleTap(tapPos, mockMapTransformer), isTrue);
      verify(mockDrawingState.selectShape(circle.id, any)).called(1);
    });
  });
  
  group('Hit-Testing Logic - Markers', () {
    final marker = MarkerShapeData(
      marker: Marker(point: LatLng(0,0), width: 20, height: 30, child: Text("M")),
      id: "marker1",
    );
     setUp(() {
      when(mockDrawingState.currentShapes).thenReturn([marker]);
      // Marker at (0,0) latlng -> (100,100)px screen
      when(mockMapTransformer.latLngToPixel(LatLng(0,0), any)).thenReturn(CustomPoint(100.0, 100.0));
    });

    test('tap on marker (center alignment default)', () {
      // Marker is 20x30. Default alignment is center.
      // So, sensitive area is from (100-10, 100-15) to (100+10, 100+15) -> (90,85) to (110,115)
      // Add _kMarkerHitThreshold (default 20)
      // Sensitive area: (90-20, 85-20) to (110+20, 115+20) -> (70,65) to (130,135)
      // Tap at (0.00001, 0.00001) -> (101,101)px (assuming simple scaling for test)
      when(mockMapTransformer.latLngToPixel(LatLng(0.00001, 0.00001), any)).thenReturn(CustomPoint(101.0, 101.0));
      expect(selectionManager.handleTap(LatLng(0.00001, 0.00001), mockMapTransformer), isTrue);
      verify(mockDrawingState.selectShape(marker.id, any)).called(1);
    });

    test('tap outside marker', () {
      // Tap at (0.0005, 0.0005) -> (150,150)px (assuming simple scaling for test)
      // This is outside the (70,65) to (130,135) sensitive area.
      when(mockMapTransformer.latLngToPixel(LatLng(0.0005, 0.0005), any)).thenReturn(CustomPoint(150.0, 150.0));
      expect(selectionManager.handleTap(LatLng(0.0005, 0.0005), mockMapTransformer), isFalse);
      verifyNever(mockDrawingState.selectShape(any, any));
    });
  });

  group('Overlapping Shapes', () {
    final poly1 = PolygonShapeData(polygon: Polygon(points: [LatLng(0,0), LatLng(0,2), LatLng(2,2), LatLng(2,0)], color: Colors.red), id: "poly1");
    final poly2 = PolygonShapeData(polygon: Polygon(points: [LatLng(1,1), LatLng(1,3), LatLng(3,3), LatLng(3,1)], color: Colors.blue), id: "poly2"); // Overlaps with poly1

    test('selects the topmost shape (last in list)', () {
      // poly2 is "on top" because it's later in the list
      when(mockDrawingState.currentShapes).thenReturn([poly1, poly2]);
      final tapPos = LatLng(1.5, 1.5); // Inside both poly1 and poly2

      expect(selectionManager.handleTap(tapPos, mockMapTransformer), isTrue);
      // Should select poly2 because it's iterated in reverse order (topmost)
      verify(mockDrawingState.selectShape(poly2.id, any)).called(1);
      verifyNever(mockDrawingState.selectShape(poly1.id, any));
    });
  });
}
