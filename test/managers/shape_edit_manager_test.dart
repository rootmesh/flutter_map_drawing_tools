import 'package:flutter/gestures.dart'; // For kPrimaryMouseButton
import 'package:flutter/material.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:flutter_map_drawing_tools/src/managers/shape_edit_manager.dart';
import 'package:flutter_map_drawing_tools/src/models/drawing_state.dart';
import 'package:flutter_map_drawing_tools/src/models/drawing_tool.dart'; // For EditMode
import 'package:flutter_map_drawing_tools/src/models/drawing_tools_options.dart';
import 'package:flutter_map_drawing_tools/src/models/shape_data_models.dart';
import 'package:flutter_map/plugin_api.dart'; // For MapTransformer
import 'package:latlong2/latlong.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:flutter_test/flutter_test.dart';

// Generate mocks for these classes
@GenerateMocks([
  DrawingState,
  DrawingToolsOptions,
  MapController,
  MapTransformer,
])
import 'shape_edit_manager_test.mocks.dart'; // This file will be generated by running build_runner

void main() {
  late MockDrawingState mockDrawingState;
  late MockDrawingToolsOptions mockOptions;
  late MockMapController mockMapController;
  late MockMapTransformer mockMapTransformer;
  late ShapeEditManager editManager;

  // Helper to create a concrete MapTransformer for tests where its internal logic isn't mocked away.
  MapTransformer getTestMapTransformer({LatLng center = const LatLng(0,0), double zoom = 13.0}) {
    return MapTransformer(
      mapState: MapState(
        crs: const Epsg3857(),
        center: center,
        zoom: zoom,
      ),
    );
  }

  final testPolygon = PolygonShapeData(
    polygon: Polygon(points: [LatLng(0,0), LatLng(0,1), LatLng(1,1), LatLng(1,0)], color: Colors.blue),
    id: "poly1",
    label: "Test Polygon",
  );

  final testCircle = CircleShapeData(
    circleMarker: CircleMarker(point: LatLng(10,10), radius: 100, color: Colors.red, useRadiusInMeter: true),
    id: "circle1",
    label: "Test Circle",
  );

  setUp(() {
    mockDrawingState = MockDrawingState();
    mockOptions = MockDrawingToolsOptions();
    mockMapController = MockMapController();
    mockMapTransformer = MockMapTransformer();

    // Default stubbing for drawingState
    when(mockDrawingState.selectedShapeId).thenReturn(null);
    when(mockDrawingState.originalShapeDataBeforeDrag).thenReturn(null);
    when(mockDrawingState.draftShapeDataWhileDragging).thenReturn(null);
    when(mockDrawingState.activeEditMode).thenReturn(EditMode.none);
    
    // Default stubbing for mapController (real MapOptions for flag manipulation)
    final realMapOptions = MapOptions(crs: const Epsg3857());
    when(mockMapController.options).thenReturn(realMapOptions);

    // Default stubbing for mapTransformer
    when(mockMapTransformer.latLngToPixel(any, any)).thenAnswer((invocation) {
      final latlng = invocation.positionalArguments[0] as LatLng;
      return CustomPoint(latlng.longitude * 1000, latlng.latitude * 1000); // Simple scaling
    });
    when(mockMapTransformer.pixelToLatLng(any, any)).thenAnswer((invocation) {
      final point = invocation.positionalArguments[0] as CustomPoint;
      return LatLng(point.y / 1000, point.x / 1000); // Inverse simple scaling
    });
     when(mockMapTransformer.centerZoom).thenReturn(MapCamera(center: LatLng(0,0), zoom: 13));


    editManager = ShapeEditManager(
      drawingState: mockDrawingState,
      options: mockOptions,
      mapController: mockMapController,
    );
    // Initialize MapTransformer for the manager
    editManager.updateMapTransformer(mockMapTransformer);
  });

  group('Initialization and Mode Changes', () {
    test('initializes correctly', () {
      expect(editManager, isNotNull);
    });

    test('onEditModeChanged initializes draft and initial shape data', () {
      when(mockDrawingState.selectedShapeId).thenReturn(testPolygon.id);
      when(mockDrawingState.originalShapeDataBeforeDrag).thenReturn(testPolygon);
      when(mockDrawingState.activeEditMode).thenReturn(EditMode.dragging); // Any edit mode

      editManager.onEditModeChanged();

      // Verify draft is set based on original
      final capturedDraft = verify(mockDrawingState.setDraftShapeDataWhileDragging(captureAny)).captured.single as ShapeData;
      expect(capturedDraft.id, testPolygon.id);
      expect(capturedDraft, isA<PolygonShapeData>());
      
      // Further check internal _initialShapeDataForEdit (not directly testable without exposing or side effects)
      // For now, trust it's set if draft is correctly initialized.
    });
    
    test('onEditModeChanged uses existing draft if available for the same shape', () {
      final modifiedPolygon = testPolygon.copyWithPolygon(testPolygon.polygon.copyWith(points: [LatLng(1,1)]));
      when(mockDrawingState.selectedShapeId).thenReturn(testPolygon.id);
      when(mockDrawingState.originalShapeDataBeforeDrag).thenReturn(testPolygon); // The true original
      when(mockDrawingState.draftShapeDataWhileDragging).thenReturn(modifiedPolygon); // An existing draft
      when(mockDrawingState.activeEditMode).thenReturn(EditMode.dragging);

      editManager.onEditModeChanged();

      // Should NOT call setDraftShapeDataWhileDragging if draft is already for selected shape
      verifyNever(mockDrawingState.setDraftShapeDataWhileDragging(any));
      // Internal _initialShapeDataForEdit should be based on the existing draft (modifiedPolygon)
    });

     test('onEditModeChanged resets edit state if no shape selected', () {
      when(mockDrawingState.selectedShapeId).thenReturn(null);
      when(mockDrawingState.activeEditMode).thenReturn(EditMode.dragging);

      editManager.onEditModeChanged();
      // Verify map interaction is reset (becomes interactive)
      expect(mockMapController.options.flags & MapInteractiveFlags.all, MapInteractiveFlags.all);
    });
  });

  group('Drag/Move Mode', () {
    setUp(() {
      when(mockDrawingState.selectedShapeId).thenReturn(testPolygon.id);
      when(mockDrawingState.originalShapeDataBeforeDrag).thenReturn(testPolygon);
      when(mockDrawingState.draftShapeDataWhileDragging).thenReturn(testPolygon.copy()); // Start with a copy
      when(mockDrawingState.activeEditMode).thenReturn(EditMode.dragging);
      editManager.onEditModeChanged(); // To set up internal states like _initialShapeDataForEdit
    });

    test('updates draft shape on drag move', () {
      final startDragPos = LatLng(0.5, 0.5); // Not used by _handleShapeDrag directly, but sets _dragStartLatLng
      final currentDragPos = LatLng(0.6, 0.6); // Drag by (0.1, 0.1)
      
      final downEvent = MapEventPointerDown(source: MapEventSource.pointerDown, camera: MapCamera.initial(), pointerPosition: startDragPos, buttons: 0);
      editManager.handleMapEvent(downEvent); // Sets _dragStartLatLng and _initialShapeDataForEdit

      final moveEvent = MapEventPointerMove(source: MapEventSource.pointerMove, camera: MapCamera.initial(), pointerPosition: currentDragPos, buttons: kPrimaryMouseButton);
      editManager.handleMapEvent(moveEvent);

      final captured = verify(mockDrawingState.setDraftShapeDataWhileDragging(captureAny)).captured.single as PolygonShapeData;
      expect(captured.id, testPolygon.id);
      // Original first point was (0,0), initial was (0,0), dragged by (0.1, 0.1) from startDragPos (0.5,0.5)
      // _initialShapeDataForEdit points are (0,0), (0,1), (1,1), (1,0)
      // _dragStartLatLng = (0.5,0.5)
      // currentDragLatLng = (0.6,0.6)
      // latDiff = 0.1, lngDiff = 0.1
      // Expected first point: (0+0.1, 0+0.1) = (0.1, 0.1)
      expect(captured.polygon.points.first.latitude, closeTo(0.1, 1e-9));
      expect(captured.polygon.points.first.longitude, closeTo(0.1, 1e-9));
    });

    test('disables map interaction during drag and re-enables on up', () {
      final startDragPos = LatLng(0.5, 0.5);
      final downEvent = MapEventPointerDown(source: MapEventSource.pointerDown, camera: MapCamera.initial(), pointerPosition: startDragPos, buttons: 0);
      editManager.handleMapEvent(downEvent);
      expect(mockMapController.options.flags & MapInteractiveFlags.drag, 0); // Drag disabled

      final upEvent = MapEventPointerUp(source: MapEventSource.pointerUp, camera: MapCamera.initial(), pointerPosition: startDragPos, buttons: 0);
      editManager.handleMapEvent(upEvent);
      expect(mockMapController.options.flags & MapInteractiveFlags.all, MapInteractiveFlags.all); // All re-enabled
    });
  });

  group('Resize Mode (handleResize)', () {
    setUp(() {
      when(mockDrawingState.selectedShapeId).thenReturn(testCircle.id);
      when(mockDrawingState.originalShapeDataBeforeDrag).thenReturn(testCircle);
      when(mockDrawingState.draftShapeDataWhileDragging).thenReturn(testCircle.copy());
      when(mockDrawingState.activeEditMode).thenReturn(EditMode.scaling);
      editManager.onEditModeChanged(); // Sets _initialShapeDataForEdit
    });

    test('resizes circle correctly', () {
      final newHandlePos = LatLng(10, 10.1); // Original center (10,10), radius 100m. New pos changes radius.
      // Expected new radius is distance from (10,10) to (10, 10.1)
      final expectedRadius = const Distance().as(LengthUnit.Meter, LatLng(10,10), newHandlePos);

      editManager.handleResize("circle_radius_handle", newHandlePos); // handleId can be arbitrary for circle scaling

      final captured = verify(mockDrawingState.setDraftShapeDataWhileDragging(captureAny)).captured.single as CircleShapeData;
      expect(captured.id, testCircle.id);
      expect(captured.circleMarker.point, testCircle.circleMarker.point); // Center shouldn't change
      expect(captured.circleMarker.radius, closeTo(expectedRadius, 0.1));
    });
    
    // Polygon scaling is placeholder, so test confirms interaction point.
    test('calls setDraftShapeDataWhileDragging for polygon resize (placeholder)', () {
      when(mockDrawingState.selectedShapeId).thenReturn(testPolygon.id);
      when(mockDrawingState.originalShapeDataBeforeDrag).thenReturn(testPolygon);
      when(mockDrawingState.draftShapeDataWhileDragging).thenReturn(testPolygon.copy());
      editManager.onEditModeChanged(); // Reset _initialShapeDataForEdit to testPolygon

      final newHandlePos = LatLng(1.1, 1.1); // New position for some handle
      editManager.handleResize("some_handle_id", newHandlePos);
      
      verify(mockDrawingState.setDraftShapeDataWhileDragging(any)).called(1);
    });
  });

  group('Rotate Mode (handleRotate)', () {
    setUp(() {
      when(mockDrawingState.selectedShapeId).thenReturn(testPolygon.id);
      when(mockDrawingState.originalShapeDataBeforeDrag).thenReturn(testPolygon); // Rotations apply to original
      when(mockDrawingState.draftShapeDataWhileDragging).thenReturn(testPolygon.copy());
      when(mockDrawingState.activeEditMode).thenReturn(EditMode.rotating);
      editManager.onEditModeChanged();
    });

    test('rotates polygon correctly', () {
      // Polygon points: (0,0), (0,1), (1,1), (1,0). Centroid approx (0.5, 0.5)
      // Drag handle to a position that implies a 90-degree rotation (PI/2 radians)
      // If original handle was at (1, 0.5) relative to center (0.5,0.5), new handle at (0.5,1)
      final dragPosFor90DegRotation = LatLng(1.0, 0.5); // Simplified: this will result in an angle.
                                                        // Actual angle depends on initial handle setup not tested here.

      editManager.handleRotate(dragPosFor90DegRotation);

      final captured = verify(mockDrawingState.setDraftShapeDataWhileDragging(captureAny)).captured.single as PolygonShapeData;
      expect(captured.id, testPolygon.id);
      // Check if points are different from original, implying rotation.
      // Detailed point checking is complex without knowing the exact reference angle.
      expect(captured.polygon.points.first.latitude, isNot(closeTo(testPolygon.polygon.points.first.latitude, 1e-3)));
      expect(captured.polygon.points.first.longitude, isNot(closeTo(testPolygon.polygon.points.first.longitude, 1e-3)));
    });
  });
  
  group('Confirm and Cancel Edit', () {
    setUp(() {
      // Simulate an ongoing edit
      when(mockDrawingState.selectedShapeId).thenReturn(testPolygon.id);
      when(mockDrawingState.originalShapeDataBeforeDrag).thenReturn(testPolygon);
      final modifiedPolygon = testPolygon.copyWithPolygon(testPolygon.polygon.copyWith(points: [LatLng(1,1)]));
      when(mockDrawingState.draftShapeDataWhileDragging).thenReturn(modifiedPolygon);
      when(mockDrawingState.activeEditMode).thenReturn(EditMode.dragging);
      // No call to onEditModeChanged here, assume it was called and _initialShapeDataForEdit is set.
    });

    test('confirmEdit updates shape and clears temporary data', () {
      editManager.confirmEdit();

      final capturedUpdate = verify(mockDrawingState.updateShape(captureAny)).captured.single as ShapeData;
      expect(capturedUpdate.id, testPolygon.id);
      expect((capturedUpdate as PolygonShapeData).polygon.points.first, LatLng(1,1)); // Check it's the modified version

      verify(mockDrawingState.setDraftShapeDataWhileDragging(null)).called(1);
      verify(mockDrawingState.setOriginalShapeDataBeforeDrag(null)).called(1);
      // Verify map interaction is reset (becomes interactive)
      expect(mockMapController.options.flags & MapInteractiveFlags.all, MapInteractiveFlags.all);
    });

    test('cancelEdit reverts shape and clears temporary data', () {
      editManager.cancelEdit();

      final capturedUpdate = verify(mockDrawingState.updateShape(captureAny)).captured.single as ShapeData;
      expect(capturedUpdate.id, testPolygon.id);
      expect((capturedUpdate as PolygonShapeData).polygon.points.first, LatLng(0,0)); // Check it's the original version

      verify(mockDrawingState.setDraftShapeDataWhileDragging(null)).called(1);
      verify(mockDrawingState.setOriginalShapeDataBeforeDrag(null)).called(1);
      // Verify map interaction is reset (becomes interactive)
      expect(mockMapController.options.flags & MapInteractiveFlags.all, MapInteractiveFlags.all);
    });
  });
  
  group('MapTransformer Usage', () {
    test('updateMapTransformer sets the internal transformer', () {
      // Initial transformer is set in setUp. Create a new one to test update.
      final newMockMapTransformer = MockMapTransformer();
      when(newMockMapTransformer.latLngToPixel(any, any)).thenReturn(CustomPoint(0.0,0.0)); // Minimal stub
      when(newMockMapTransformer.pixelToLatLng(any, any)).thenReturn(LatLng(0,0));
      when(newMockMapTransformer.centerZoom).thenReturn(MapCamera(center: LatLng(1,1), zoom: 10));

      editManager.updateMapTransformer(newMockMapTransformer);
      
      // To verify it's used, we can trigger an action that uses the transformer,
      // e.g. handleRotate, and check if the new transformer's methods are called.
      when(mockDrawingState.selectedShapeId).thenReturn(testPolygon.id);
      when(mockDrawingState.originalShapeDataBeforeDrag).thenReturn(testPolygon);
      when(mockDrawingState.draftShapeDataWhileDragging).thenReturn(testPolygon.copy());
      when(mockDrawingState.activeEditMode).thenReturn(EditMode.rotating);
      editManager.onEditModeChanged(); // Uses the currently set transformer for centroid calculation if needed

      editManager.handleRotate(LatLng(1,1));
      
      // Verify that methods on the NEW transformer were called
      verify(newMockMapTransformer.latLngToPixel(any, any)).called(greaterThan(0));
    });
  });

  group('Dispose', () {
    test('dispose re-enables map interaction if edit was active', () {
      // Simulate starting a drag
      when(mockDrawingState.selectedShapeId).thenReturn(testPolygon.id);
      when(mockDrawingState.originalShapeDataBeforeDrag).thenReturn(testPolygon);
      when(mockDrawingState.draftShapeDataWhileDragging).thenReturn(testPolygon.copy());
      when(mockDrawingState.activeEditMode).thenReturn(EditMode.dragging);
      editManager.onEditModeChanged();
      
      final downEvent = MapEventPointerDown(source: MapEventSource.pointerDown, camera: MapCamera.initial(), pointerPosition: LatLng(0,0), buttons: 0);
      editManager.handleMapEvent(downEvent); // This will disable map interaction
      expect(mockMapController.options.flags & MapInteractiveFlags.drag, 0);


      editManager.dispose();
      // Expect map to be interactive again after dispose
      expect(mockMapController.options.flags & MapInteractiveFlags.all, MapInteractiveFlags.all);
    });
  });
}
