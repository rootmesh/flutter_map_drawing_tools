import 'package:flutter/material.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:flutter_map_drawing_tools/src/managers/new_shape_gesture_manager.dart';
import 'package:flutter_map_drawing_tools/src/models/drawing_state.dart';
import 'package:flutter_map_drawing_tools/src/models/drawing_tool.dart';
import 'package:flutter_map_drawing_tools/src/models/drawing_tools_options.dart';
import 'package:flutter_map_drawing_tools/src/models/shape_data_models.dart';
import 'package:latlong2/latlong.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:flutter_test/flutter_test.dart';

// Generate mocks for these classes
@GenerateMocks([
  DrawingState,
  DrawingToolsOptions,
  MapController,
], customMocks: [
  MockSpec<Function(ShapeData)>(as: #MockShapeFinalizedCallback, returnNullOnMissingStub: true),
  MockSpec<Function(String)>(as: #MockPlacementInvalidCallback, returnNullOnMissingStub: true),
])
import 'new_shape_gesture_manager_test.mocks.dart'; // This file will be generated by running build_runner

void main() {
  late MockDrawingState mockDrawingState;
  late MockDrawingToolsOptions mockOptions;
  late MockMapController mockMapController;
  late MockShapeFinalizedCallback mockShapeFinalizedCallback;
  late MockPlacementInvalidCallback mockPlacementInvalidCallback;
  late NewShapeGestureManager gestureManager;
  late MapTransformer mockMapTransformer; // MapTransformer is concrete, but its methods might need specific setup if complex

  // Helper to create a MapTransformer. For unit tests, its actual transform logic isn't critical,
  // but it needs to be instantiated.
  MapTransformer _getMapTransformer() {
    return MapTransformer(
      mapState: MapState(
        crs: const Epsg3857(),
        center: LatLng(0,0),
        zoom: 13,
      ),
    );
  }


  setUp(() {
    mockDrawingState = MockDrawingState();
    mockOptions = MockDrawingToolsOptions();
    mockMapController = MockMapController();
    mockShapeFinalizedCallback = MockShapeFinalizedCallback();
    mockPlacementInvalidCallback = MockPlacementInvalidCallback();
    mockMapTransformer = _getMapTransformer(); // Initialize the concrete MapTransformer

    // Default stubbing for options
    when(mockOptions.validDrawingColor).thenReturn(Colors.blue);
    when(mockOptions.invalidDrawingColor).thenReturn(Colors.red);
    when(mockOptions.temporaryLineColor).thenReturn(Colors.grey);
    when(mockOptions.drawingFillColor).thenReturn(Colors.blue.withOpacity(0.3));
    when(mockOptions.pointMarkerSize).thenReturn(30.0);
    when(mockOptions.getPointIcon(any, any)).thenReturn(Icon(Icons.location_on, color: Colors.blue, size: 30));
    when(mockOptions.validateShapePlacement).thenReturn(null); // Default to no validation
    when(mockOptions.onPlacementInvalid).thenReturn(mockPlacementInvalidCallback);


    // Default stubbing for drawingState
    when(mockDrawingState.currentTool).thenReturn(DrawingTool.none);
    when(mockDrawingState.temporaryShape).thenReturn(null);
    when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(false);
    when(mockDrawingState.activeMultiPartTool).thenReturn(DrawingTool.none);
    when(mockDrawingState.currentDrawingParts).thenReturn([]);
    
    // Default stubbing for mapController
    // MapOptions is accessed directly, so ensure it's there.
    // For flags, we need to mock the behavior if we were to verify MapOptions changes.
    // However, MapController.options is final, so we might need to pass a custom MapOptions for tests.
    // For simplicity, we assume direct flag manipulation on a real MapOptions object for now.
    // If MapOptions itself needs mocking, the setup gets more complex.
    // Let's use a real MapOptions object for MapController.
    final realMapOptions = MapOptions(crs: const Epsg3857());
    when(mockMapController.options).thenReturn(realMapOptions);


    gestureManager = NewShapeGestureManager(
      drawingState: mockDrawingState,
      options: mockOptions,
      mapController: mockMapController,
      onShapeFinalized: mockShapeFinalizedCallback,
    );
  });

  group('Initialization', () {
    test('initializes correctly', () {
      expect(gestureManager, isNotNull);
    });
  });

  group('Point Shape Creation', () {
    setUp(() {
      when(mockDrawingState.currentTool).thenReturn(DrawingTool.point);
    });

    test('valid point placement', () {
      final tapPos = LatLng(10, 20);
      final tapEvent = MapEventTap(source: MapEventSource.tap, camera: MapCamera(center: LatLng(0,0), zoom: 1), tapPosition: tapPos);

      gestureManager.handleMapEvent(tapEvent, mockMapTransformer);

      // Verify onShapeFinalized is called with MarkerShapeData
      final captured = verify(mockShapeFinalizedCallback(captureAny)).captured;
      expect(captured.single, isA<MarkerShapeData>());
      final markerShape = captured.single as MarkerShapeData;
      expect(markerShape.marker.point, equals(tapPos));
      verifyNever(mockPlacementInvalidCallback(any));
      verify(mockDrawingState.setCurrentTool(DrawingTool.none)).called(1);
    });

    test('invalid point placement', () {
      final tapPos = LatLng(10, 20);
      final tapEvent = MapEventTap(source: MapEventSource.tap, camera: MapCamera(center: LatLng(0,0), zoom: 1), tapPosition: tapPos);
      
      when(mockOptions.validateShapePlacement).thenReturn((points) => false);

      gestureManager.handleMapEvent(tapEvent, mockMapTransformer);

      verify(mockPlacementInvalidCallback(any)).called(1);
      verifyNever(mockShapeFinalizedCallback(any));
      // setCurrentTool should not be called if placement is invalid and finalize is aborted
      verifyNever(mockDrawingState.setCurrentTool(DrawingTool.none));
    });
  });

  group('Circle Shape Creation', () {
    final centerPos = LatLng(10, 20);
    final radiusPos = LatLng(10.1, 20.1); // Approx 15.7km radius

    setUp(() {
      when(mockDrawingState.currentTool).thenReturn(DrawingTool.circle);
    });

    test('valid circle creation', () {
      final downEvent = MapEventPointerDown(source: MapEventSource.pointerDown, camera: MapCamera.initial(), pointerPosition: centerPos, buttons: 0);
      final moveEvent = MapEventPointerMove(source: MapEventSource.pointerMove, camera: MapCamera.initial(), pointerPosition: radiusPos, buttons: kPrimaryMouseButton);
      final upEvent = MapEventPointerUp(source: MapEventSource.pointerUp, camera: MapCamera.initial(), pointerPosition: radiusPos, buttons: 0);

      gestureManager.handleMapEvent(downEvent, mockMapTransformer);
       verify(mockDrawingState.setTemporaryShape(any)).called(1);
       final initialDraft = clearInteractions(mockDrawingState).captured.last['setTemporaryShape'][0] as CircleShapeData;
       expect(initialDraft.circleMarker.point, centerPos);


      gestureManager.handleMapEvent(moveEvent, mockMapTransformer);
      verify(mockDrawingState.setTemporaryShape(any)).called(1);
      final movedDraft = clearInteractions(mockDrawingState).captured.last['setTemporaryShape'][0] as CircleShapeData;
      expect(movedDraft.circleMarker.point, centerPos);
      expect(movedDraft.circleMarker.radius, greaterThan(1.0));


      gestureManager.handleMapEvent(upEvent, mockMapTransformer);
      final captured = verify(mockShapeFinalizedCallback(captureAny)).captured;
      expect(captured.single, isA<CircleShapeData>());
      final circleShape = captured.single as CircleShapeData;
      expect(circleShape.circleMarker.point, equals(centerPos));
      expect(circleShape.circleMarker.radius, closeTo(const Distance().as(LengthUnit.Meter, centerPos, radiusPos), 0.1));
      verifyNever(mockPlacementInvalidCallback(any));
    });

    test('invalid initial circle placement', () {
      when(mockOptions.validateShapePlacement).thenReturn((points) => points.first == radiusPos); // Only radiusPos is valid
      
      final downEvent = MapEventPointerDown(source: MapEventSource.pointerDown, camera: MapCamera.initial(), pointerPosition: centerPos, buttons: 0);
      gestureManager.handleMapEvent(downEvent, mockMapTransformer);

      verify(mockPlacementInvalidCallback(any)).called(1);
      verify(mockDrawingState.setTemporaryShape(any)).called(1); // Should still show invalid draft
      final draft = clearInteractions(mockDrawingState).captured.last['setTemporaryShape'][0] as CircleShapeData;
      expect(draft.circleMarker.color, mockOptions.invalidDrawingColor.withOpacity(0.3));


      final upEvent = MapEventPointerUp(source: MapEventSource.pointerUp, camera: MapCamera.initial(), pointerPosition: centerPos, buttons: 0);
      gestureManager.handleMapEvent(upEvent, mockMapTransformer);
      verify(mockPlacementInvalidCallback(any)).called(1); // Called again on finalize attempt
      verifyNever(mockShapeFinalizedCallback(any));
    });
     test('invalid circle placement during drag, then valid', () {
      final invalidDragPos = LatLng(1,1);
      final validDragPos = LatLng(10.1, 20.1); // radiusPos

      bool isDragValid = false;
      when(mockOptions.validateShapePlacement).thenReturn((points) {
        // Center is always valid for this test, drag point determines validity of radius
        if (points.length == 1 && points.first == centerPos) return true; // Initial center placement
        return isDragValid; // Validity of the circle based on its current radius/center
      });
      
      final downEvent = MapEventPointerDown(source: MapEventSource.pointerDown, camera: MapCamera.initial(), pointerPosition: centerPos, buttons: 0);
      gestureManager.handleMapEvent(downEvent, mockMapTransformer); // Valid center

      isDragValid = false;
      final moveEventInvalid = MapEventPointerMove(source: MapEventSource.pointerMove, camera: MapCamera.initial(), pointerPosition: invalidDragPos, buttons: kPrimaryMouseButton);
      gestureManager.handleMapEvent(moveEventInvalid, mockMapTransformer);
      verify(mockPlacementInvalidCallback(any)).called(1); // Called for invalid drag
      verify(mockDrawingState.setTemporaryShape(any)).called(1);
       final invalidDraft = clearInteractions(mockDrawingState).captured.last['setTemporaryShape'][0] as CircleShapeData;
       expect(invalidDraft.circleMarker.color, mockOptions.invalidDrawingColor.withOpacity(0.3));


      isDragValid = true;
      final moveEventValid = MapEventPointerMove(source: MapEventSource.pointerMove, camera: MapCamera.initial(), pointerPosition: validDragPos, buttons: kPrimaryMouseButton);
      gestureManager.handleMapEvent(moveEventValid, mockMapTransformer);
      verifyNever(mockPlacementInvalidCallback(any)); // Should not be called again if it becomes valid
       verify(mockDrawingState.setTemporaryShape(any)).called(1);
       final validDraft = clearInteractions(mockDrawingState).captured.last['setTemporaryShape'][0] as CircleShapeData;
       expect(validDraft.circleMarker.color, mockOptions.temporaryLineColor.withOpacity(0.3));


      final upEvent = MapEventPointerUp(source: MapEventSource.pointerUp, camera: MapCamera.initial(), pointerPosition: validDragPos, buttons: 0);
      gestureManager.handleMapEvent(upEvent, mockMapTransformer);
      verify(mockShapeFinalizedCallback(any)).called(1);
    });

  });

  group('Rectangle/Square Shape Creation', () {
    final startRectPos = LatLng(30, 40);
    final endRectPos = LatLng(30.1, 40.1);

    test('valid rectangle creation', () {
      when(mockDrawingState.currentTool).thenReturn(DrawingTool.rectangle);
      final downEvent = MapEventPointerDown(source: MapEventSource.pointerDown, camera: MapCamera.initial(), pointerPosition: startRectPos, buttons: 0);
      final moveEvent = MapEventPointerMove(source: MapEventSource.pointerMove, camera: MapCamera.initial(), pointerPosition: endRectPos, buttons: kPrimaryMouseButton);
      final upEvent = MapEventPointerUp(source: MapEventSource.pointerUp, camera: MapCamera.initial(), pointerPosition: endRectPos, buttons: 0);

      gestureManager.handleMapEvent(downEvent, mockMapTransformer);
      verify(mockDrawingState.setTemporaryShape(any)).called(1);

      gestureManager.handleMapEvent(moveEvent, mockMapTransformer);
      verify(mockDrawingState.setTemporaryShape(any)).called(1);

      gestureManager.handleMapEvent(upEvent, mockMapTransformer);
      final captured = verify(mockShapeFinalizedCallback(captureAny)).captured;
      expect(captured.single, isA<PolygonShapeData>());
      final polygonShape = captured.single as PolygonShapeData;
      expect(polygonShape.polygon.points.length, 5); // 4 corners + close
      expect(polygonShape.polygon.points.first, startRectPos);
      expect(polygonShape.polygon.points[2], endRectPos);
      verifyNever(mockPlacementInvalidCallback(any));
    });
    
    test('valid square creation', () {
      when(mockDrawingState.currentTool).thenReturn(DrawingTool.square);
      final downEvent = MapEventPointerDown(source: MapEventSource.pointerDown, camera: MapCamera.initial(), pointerPosition: startRectPos, buttons: 0);
      // For square, endRectPos might be adjusted. Let's use one that forces a specific side length.
      final endSquareDragPos = LatLng(startRectPos.latitude + 0.1, startRectPos.longitude + 0.05); // deltaLat > deltaLng
      
      final moveEvent = MapEventPointerMove(source: MapEventSource.pointerMove, camera: MapCamera.initial(), pointerPosition: endSquareDragPos, buttons: kPrimaryMouseButton);
      final upEvent = MapEventPointerUp(source: MapEventSource.pointerUp, camera: MapCamera.initial(), pointerPosition: endSquareDragPos, buttons: 0);

      gestureManager.handleMapEvent(downEvent, mockMapTransformer);
      verify(mockDrawingState.setTemporaryShape(any)).called(1);

      gestureManager.handleMapEvent(moveEvent, mockMapTransformer);
      verify(mockDrawingState.setTemporaryShape(any)).called(1);
      final draftSquare = clearInteractions(mockDrawingState).captured.last['setTemporaryShape'][0] as PolygonShapeData;
      final p = draftSquare.polygon.points;
      // Check if it's a square (approximate due to LatLng math)
      // Side 1-2 vs Side 2-3 (in degrees for simplicity in test, real check is more complex)
      final side1Lat = (p[1].latitude - p[0].latitude).abs();
      final side1Lng = (p[1].longitude - p.first.longitude).abs();
      final side2Lat = (p[2].latitude - p[1].latitude).abs();
      final side2Lng = (p[2].longitude - p[1].longitude).abs();
      // One side should be primarily lat, other primarily lng for axis-aligned rect
      // And their lengths (in degrees) should be similar for a square
      // This test is simplified. A more robust check would involve MapTransformer.
      expect((side1Lat + side1Lng), closeTo((side2Lat + side2Lng), 0.001));


      gestureManager.handleMapEvent(upEvent, mockMapTransformer);
      final captured = verify(mockShapeFinalizedCallback(captureAny)).captured;
      expect(captured.single, isA<PolygonShapeData>());
    });


    test('invalid rectangle placement during drag', () {
      when(mockDrawingState.currentTool).thenReturn(DrawingTool.rectangle);
      bool isDragValid = true;
      when(mockOptions.validateShapePlacement).thenReturn((points) => isDragValid);

      final downEvent = MapEventPointerDown(source: MapEventSource.pointerDown, camera: MapCamera.initial(), pointerPosition: startRectPos, buttons: 0);
      gestureManager.handleMapEvent(downEvent, mockMapTransformer); // Valid start

      isDragValid = false; // Make subsequent drags invalid
      final moveEvent = MapEventPointerMove(source: MapEventSource.pointerMove, camera: MapCamera.initial(), pointerPosition: endRectPos, buttons: kPrimaryMouseButton);
      gestureManager.handleMapEvent(moveEvent, mockMapTransformer);
      
      verify(mockPlacementInvalidCallback(any)).called(1);
      verify(mockDrawingState.setTemporaryShape(any)).called(1); // For initial valid, then for invalid
      final draft = clearInteractions(mockDrawingState).captured.last['setTemporaryShape'][0] as PolygonShapeData;
      expect(draft.polygon.borderColor, mockOptions.invalidDrawingColor);

      final upEvent = MapEventPointerUp(source: MapEventSource.pointerUp, camera: MapCamera.initial(), pointerPosition: endRectPos, buttons: 0);
      gestureManager.handleMapEvent(upEvent, mockMapTransformer);
      verify(mockPlacementInvalidCallback(any)).called(1); // Called again on finalize attempt
      verifyNever(mockShapeFinalizedCallback(any));
    });
  });

  group('Polyline/Polygon Point Addition', () {
    test('adds points for polyline', () {
      when(mockDrawingState.currentTool).thenReturn(DrawingTool.polyline);
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(false); // Initially not drawing
      
      final tap1 = LatLng(0,0);
      final tapEvent1 = MapEventTap(source: MapEventSource.tap, camera: MapCamera.initial(), tapPosition: tap1);
      gestureManager.handleMapEvent(tapEvent1, mockMapTransformer);
      verify(mockDrawingState.startNewDrawingPart(DrawingTool.polyline)).called(1);
      verify(mockDrawingState.addPointToCurrentPart(tap1)).called(1);

      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(true); // Now drawing
      final tap2 = LatLng(1,1);
      final tapEvent2 = MapEventTap(source: MapEventSource.tap, camera: MapCamera.initial(), tapPosition: tap2);
      gestureManager.handleMapEvent(tapEvent2, mockMapTransformer);
      verifyNever(mockDrawingState.startNewDrawingPart(any)); // Should not start new part
      verify(mockDrawingState.addPointToCurrentPart(tap2)).called(1);
    });
  });

  group('Multi-Part Shape Finalization (finalizeMultiPartShape)', () {
    test('valid polygon finalization', () {
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(true);
      when(mockDrawingState.activeMultiPartTool).thenReturn(DrawingTool.polygon);
      final exterior = [LatLng(0,0), LatLng(0,1), LatLng(1,1), LatLng(1,0)];
      when(mockDrawingState.consumeDrawingParts()).thenReturn([exterior]);

      gestureManager.finalizeMultiPartShape();
      
      final captured = verify(mockShapeFinalizedCallback(captureAny)).captured;
      expect(captured.single, isA<PolygonShapeData>());
      final poly = captured.single as PolygonShapeData;
      expect(poly.polygon.points.length, 5); // Closed
      expect(poly.polygon.points.first, exterior.first);
      expect(poly.polygon.points.last, exterior.first);
      verifyNever(mockPlacementInvalidCallback(any));
      verify(mockDrawingState.setCurrentTool(DrawingTool.none)).called(1);
    });

    test('invalid polygon finalization (exterior ring)', () {
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(true);
      when(mockDrawingState.activeMultiPartTool).thenReturn(DrawingTool.polygon);
      final exterior = [LatLng(0,0), LatLng(0,1), LatLng(1,1), LatLng(1,0)];
      when(mockDrawingState.consumeDrawingParts()).thenReturn([exterior]);
      when(mockOptions.validateShapePlacement).thenReturn((points) => false); // Make it invalid

      gestureManager.finalizeMultiPartShape();

      verify(mockPlacementInvalidCallback(any)).called(1);
      verifyNever(mockShapeFinalizedCallback(any));
      verify(mockDrawingState.setCurrentTool(DrawingTool.none)).called(1);
    });
     test('valid polyline finalization', () {
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(true);
      when(mockDrawingState.activeMultiPartTool).thenReturn(DrawingTool.polyline);
      final part1 = [LatLng(0,0), LatLng(0,1)];
      final part2 = [LatLng(1,1), LatLng(1,0)];
      when(mockDrawingState.consumeDrawingParts()).thenReturn([part1, part2]);

      gestureManager.finalizeMultiPartShape();
      
      final captured = verify(mockShapeFinalizedCallback(captureAny)).captured;
      expect(captured.length, 2);
      expect(captured.first, isA<PolylineShapeData>());
      expect((captured.first as PolylineShapeData).polyline.points, part1);
      expect(captured.last, isA<PolylineShapeData>());
      expect((captured.last as PolylineShapeData).polyline.points, part2);
      verifyNever(mockPlacementInvalidCallback(any));
    });
  });
  
  group('Map Interaction Control', () {
    test('sets map interactive flags correctly for circle drawing', () {
      when(mockDrawingState.currentTool).thenReturn(DrawingTool.circle);
      final centerPos = LatLng(10, 20);
      final radiusPos = LatLng(10.1, 20.1);

      final downEvent = MapEventPointerDown(source: MapEventSource.pointerDown, camera: MapCamera.initial(), pointerPosition: centerPos, buttons: 0);
      gestureManager.handleMapEvent(downEvent, mockMapTransformer);
      // Expect map to be non-interactive after pointer down for circle
      expect(mockMapController.options.flags & MapInteractiveFlags.all, 0);

      final moveEvent = MapEventPointerMove(source: MapEventSource.pointerMove, camera: MapCamera.initial(), pointerPosition: radiusPos, buttons: kPrimaryMouseButton);
      gestureManager.handleMapEvent(moveEvent, mockMapTransformer);
      // Still non-interactive during move
      expect(mockMapController.options.flags & MapInteractiveFlags.all, 0);

      final upEvent = MapEventPointerUp(source: MapEventSource.pointerUp, camera: MapCamera.initial(), pointerPosition: radiusPos, buttons: 0);
      gestureManager.handleMapEvent(upEvent, mockMapTransformer);
      // Expect map to be interactive again after pointer up
      expect(mockMapController.options.flags & MapInteractiveFlags.all, MapInteractiveFlags.all);
    });

    test('dispose re-enables map interaction if drawing was interrupted', () {
      when(mockDrawingState.currentTool).thenReturn(DrawingTool.circle);
      final centerPos = LatLng(10, 20);
      
      final downEvent = MapEventPointerDown(source: MapEventSource.pointerDown, camera: MapCamera.initial(), pointerPosition: centerPos, buttons: 0);
      gestureManager.handleMapEvent(downEvent, mockMapTransformer);
      expect(mockMapController.options.flags & MapInteractiveFlags.all, 0); // Disabled

      gestureManager.dispose();
      // Expect map to be interactive again after dispose
      expect(mockMapController.options.flags & MapInteractiveFlags.all, MapInteractiveFlags.all);
    });
  });

}
