import 'package:flutter/material.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:flutter_map_drawing_tools/src/managers/poly_editor_manager.dart';
import 'package:flutter_map_drawing_tools/src/models/drawing_state.dart';
import 'package:flutter_map_drawing_tools/src/models/drawing_tool.dart';
import 'package:flutter_map_drawing_tools/src/models/drawing_tools_options.dart';
import 'package:flutter_map_drawing_tools/src/models/shape_data_models.dart';
import 'package:flutter_map_line_editor/flutter_map_line_editor.dart'; // For PolyEditor
import 'package:latlong2/latlong.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:flutter_test/flutter_test.dart';

// Generate mocks for these classes
@GenerateMocks([
  DrawingState,
  DrawingToolsOptions,
], customMocks: [
   MockSpec<VoidCallback>(as: #MockVoidCallback, returnNullOnMissingStub: true),
   MockSpec<Function(String)>(as: #MockPlacementInvalidCallback, returnNullOnMissingStub: true),
])
import 'poly_editor_manager_test.mocks.dart'; // This file will be generated by running build_runner

void main() {
  late MockDrawingState mockDrawingState;
  late MockDrawingToolsOptions mockOptions;
  late MockVoidCallback mockRefreshCallback; // For PolyEditor's callbackRefresh
  late MockPlacementInvalidCallback mockPlacementInvalidCallback; // For options.onPlacementInvalid
  late PolyEditorManager polyEditorManager;

  final testPolyline = PolylineShapeData(
    polyline: Polyline(points: [LatLng(0,0), LatLng(1,1)], color: Colors.blue, strokeWidth: 3),
    id: "line1",
  );

  final testPolygon = PolygonShapeData(
    polygon: Polygon(points: [LatLng(0,0), LatLng(0,1), LatLng(1,1), LatLng(1,0), LatLng(0,0)], color: Colors.red, isFilled: true),
    id: "poly1",
  );
  
  // Default icons for verification
  final defaultVertexIcon = Icon(Icons.circle, color: Colors.orangeAccent, size: 20);
  final defaultIntermediateIcon = Icon(Icons.add_circle_outline, color: Colors.orangeAccent.withOpacity(0.7), size: 15);


  setUp(() {
    mockDrawingState = MockDrawingState();
    mockOptions = MockDrawingToolsOptions();
    mockRefreshCallback = MockVoidCallback();
    mockPlacementInvalidCallback = MockPlacementInvalidCallback();

    // Default stubbing for options
    when(mockOptions.vertexHandleIcon).thenReturn(defaultVertexIcon);
    when(mockOptions.intermediateVertexHandleIcon).thenReturn(defaultIntermediateIcon);
    when(mockOptions.temporaryLineColor).thenReturn(Colors.grey);
    when(mockOptions.editingHandleColor).thenReturn(Colors.orangeAccent);
    when(mockOptions.invalidDrawingColor).thenReturn(Colors.red);
    when(mockOptions.validateShapePlacement).thenReturn(null); // Default to no validation / always valid
    when(mockOptions.onPlacementInvalid).thenReturn(mockPlacementInvalidCallback);


    // Default stubbing for drawingState
    when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(false);
    when(mockDrawingState.activeMultiPartTool).thenReturn(DrawingTool.none);
    when(mockDrawingState.currentDrawingParts).thenReturn([]);
    when(mockDrawingState.selectedShapeId).thenReturn(null);
    when(mockDrawingState.activeEditMode).thenReturn(EditMode.none);
    when(mockDrawingState.findShapeById(any)).thenReturn(null);


    polyEditorManager = PolyEditorManager(
      drawingState: mockDrawingState,
      options: mockOptions,
      onRefresh: mockRefreshCallback,
    );
    // PolyEditorManager adds its listener in initPolyEditor, so call it here.
    polyEditorManager.initPolyEditor(); 
    // Clear interactions from init, as it calls reinitializePolyEditorState
    clearInteractions(mockRefreshCallback); 
  });

  tearDown(() {
    // Crucial for tests involving listeners to avoid interference
    polyEditorManager.dispose(); 
  });

  group('Initialization and DrawingState Listener', () {
    test('initializes PolyEditor with styles and callback', () {
      // initPolyEditor is called in setUp
      expect(polyEditorManager.instance, isNotNull);
      expect(polyEditorManager.instance!.pointIcon, equals(defaultVertexIcon));
      expect(polyEditorManager.instance!.intermediateIcon, equals(defaultIntermediateIcon));
      expect(polyEditorManager.instance!.polygonEditorOptions.lineColor, mockOptions.temporaryLineColor);
      
      // Simulate PolyEditor calling its refresh
      polyEditorManager.instance!.test(); // This should trigger callbackRefresh
      verify(mockRefreshCallback()).called(1);
    });

    test('listener is added to DrawingState and removed on dispose', () {
      // Verify listener was added (implicitly by checking if reinitialize is called on change)
      // To test this, we need to make drawingState.addListener capture the callback or use a spy.
      // For simplicity, we'll trust it's added in init and test removal.
      
      // Create a fresh manager for this specific listener test to avoid dispose issues from setUp
      final freshManager = PolyEditorManager(drawingState: mockDrawingState, options: mockOptions, onRefresh: mockRefreshCallback);
      // Listener not added yet
      verifyNever(mockDrawingState.addListener(any));
      freshManager.initPolyEditor();
      verify(mockDrawingState.addListener(any)).called(1); // Listener added
      
      freshManager.dispose();
      verify(mockDrawingState.removeListener(any)).called(1); // Listener removed
    });
  });

  group('reinitializePolyEditorState() - Core Logic', () {
    test('No active tool/shape: PolyEditor is cleared/inactive', () {
      // Ensure state is "idle"
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(false);
      when(mockDrawingState.selectedShapeId).thenReturn(null);
      
      polyEditorManager.reinitializePolyEditorState();

      expect(polyEditorManager.instance!.points, isEmpty);
      expect(polyEditorManager.instance!.addClosePathMarker, isFalse);
      expect(polyEditorManager.isCurrentContentInvalid, isFalse); // Should be valid if empty
      // Check _isActive (not directly exposed, but affects getEditMarkers/getPolylineForRendering)
      expect(polyEditorManager.getEditMarkers(), isEmpty);
      expect(polyEditorManager.getPolylineForRendering(), isNull);
    });

    test('Drawing New Multi-Part Polyline', () {
      final points = [LatLng(10,10), LatLng(11,11)];
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(true);
      when(mockDrawingState.activeMultiPartTool).thenReturn(DrawingTool.polyline);
      when(mockDrawingState.currentDrawingParts).thenReturn([points]);

      polyEditorManager.reinitializePolyEditorState();

      expect(polyEditorManager.instance!.points, equals(points));
      expect(polyEditorManager.instance!.addClosePathMarker, isFalse);
      expect(polyEditorManager.isCurrentContentInvalid, isFalse); // Default valid
      expect(polyEditorManager.getPolylineForRendering()?.color, mockOptions.temporaryLineColor);
    });

    test('Drawing New Multi-Part Polygon', () {
      final points = [LatLng(20,20), LatLng(21,21), LatLng(22,20)];
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(true);
      when(mockDrawingState.activeMultiPartTool).thenReturn(DrawingTool.polygon);
      when(mockDrawingState.currentDrawingParts).thenReturn([points]);

      polyEditorManager.reinitializePolyEditorState();

      expect(polyEditorManager.instance!.points, equals(points));
      expect(polyEditorManager.instance!.addClosePathMarker, isTrue); // For polygon with >1 points
      expect(polyEditorManager.isCurrentContentInvalid, isFalse);
      expect(polyEditorManager.getPolylineForRendering()?.color, mockOptions.temporaryLineColor);
    });
    
    test('Vertex Editing Existing Polyline', () {
      when(mockDrawingState.selectedShapeId).thenReturn(testPolyline.id);
      when(mockDrawingState.findShapeById(testPolyline.id)).thenReturn(testPolyline);
      when(mockDrawingState.activeEditMode).thenReturn(EditMode.vertexEditing);

      polyEditorManager.reinitializePolyEditorState();

      expect(polyEditorManager.instance!.points, equals(testPolyline.points));
      expect(polyEditorManager.instance!.addClosePathMarker, isFalse);
      expect(polyEditorManager.getPolylineForRendering()?.color, mockOptions.editingHandleColor.withOpacity(0.8));
    });

    test('Vertex Editing Existing Polygon (closed)', () {
      when(mockDrawingState.selectedShapeId).thenReturn(testPolygon.id);
      when(mockDrawingState.findShapeById(testPolygon.id)).thenReturn(testPolygon);
      when(mockDrawingState.activeEditMode).thenReturn(EditMode.vertexEditing);

      polyEditorManager.reinitializePolyEditorState();
      
      // PolyEditor expects open path for polygons, so last point should be removed if it closes the path
      final expectedPoints = List<LatLng>.from(testPolygon.points)..removeLast();
      expect(polyEditorManager.instance!.points, equals(expectedPoints));
      expect(polyEditorManager.instance!.addClosePathMarker, isTrue);
      expect(polyEditorManager.getPolylineForRendering()?.color, mockOptions.editingHandleColor.withOpacity(0.8));
    });
  });

  group('Styling from DrawingToolsOptions', () {
    test('PolyEditor uses correct line color for new multipart polyline', () {
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(true);
      when(mockDrawingState.activeMultiPartTool).thenReturn(DrawingTool.polyline);
      when(mockDrawingState.currentDrawingParts).thenReturn([[LatLng(0,0)]]);
      
      polyEditorManager.reinitializePolyEditorState();
      expect(polyEditorManager.instance!.polygonEditorOptions.lineColor, mockOptions.temporaryLineColor);
    });

    test('PolyEditor uses correct line color for vertex editing', () {
      when(mockDrawingState.selectedShapeId).thenReturn(testPolyline.id);
      when(mockDrawingState.findShapeById(testPolyline.id)).thenReturn(testPolyline);
      when(mockDrawingState.activeEditMode).thenReturn(EditMode.vertexEditing);

      polyEditorManager.reinitializePolyEditorState();
      expect(polyEditorManager.instance!.polygonEditorOptions.lineColor, mockOptions.editingHandleColor.withOpacity(0.8));
    });
  });
  
  group('Invalid Placement Indication (New Multi-Part Segments)', () {
    final points = [LatLng(10,10), LatLng(11,11)];
    setUp(() {
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(true);
      when(mockDrawingState.activeMultiPartTool).thenReturn(DrawingTool.polyline);
      when(mockDrawingState.currentDrawingParts).thenReturn([points]);
    });

    test('sets invalid state and calls callback if placement is invalid', () {
      when(mockOptions.validateShapePlacement).thenReturn((p) => false); // Always invalid

      polyEditorManager.reinitializePolyEditorState();

      expect(polyEditorManager.isCurrentContentInvalid, isTrue);
      verify(mockPlacementInvalidCallback(any)).called(1);
      expect(polyEditorManager.getPolylineForRendering()?.color, mockOptions.invalidDrawingColor);
      // Also check the PolyEditor's own line color if it's distinct
      expect(polyEditorManager.instance!.polygonEditorOptions.lineColor, mockOptions.invalidDrawingColor);
    });

    test('maintains valid state if placement is valid', () {
      when(mockOptions.validateShapePlacement).thenReturn((p) => true); // Always valid

      polyEditorManager.reinitializePolyEditorState();

      expect(polyEditorManager.isCurrentContentInvalid, isFalse);
      verifyNever(mockPlacementInvalidCallback(any));
      expect(polyEditorManager.getPolylineForRendering()?.color, mockOptions.temporaryLineColor);
    });
  });

  group('Access to Renderables', () {
    test('getEditMarkers returns empty list when inactive', () {
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(false);
      when(mockDrawingState.selectedShapeId).thenReturn(null);
      polyEditorManager.reinitializePolyEditorState(); // Ensure inactive state
      expect(polyEditorManager.getEditMarkers(), isEmpty);
    });

    test('getEditMarkers returns markers when active', () {
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(true);
      when(mockDrawingState.currentDrawingParts).thenReturn([[LatLng(0,0), LatLng(1,1)]]);
      polyEditorManager.reinitializePolyEditorState(); // Activate
      
      // PolyEditor.edit() creates new marker instances, so we can't compare directly.
      // Check that it returns a non-empty list of DragMarkers.
      // For 2 points, it should have 2 vertex markers and 1 intermediate.
      expect(polyEditorManager.getEditMarkers(), isNotEmpty);
      expect(polyEditorManager.getEditMarkers().length, 3); 
    });

    test('getPolylineForRendering returns null when inactive', () {
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(false);
      when(mockDrawingState.selectedShapeId).thenReturn(null);
      polyEditorManager.reinitializePolyEditorState();
      expect(polyEditorManager.getPolylineForRendering(), isNull);
    });
    
    test('getPolylineForRendering returns styled polyline when active', () {
      final points = [LatLng(0,0), LatLng(1,1)];
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(true);
      when(mockDrawingState.currentDrawingParts).thenReturn([points]);
      polyEditorManager.reinitializePolyEditorState();

      final renderedPolyline = polyEditorManager.getPolylineForRendering();
      expect(renderedPolyline, isNotNull);
      expect(renderedPolyline!.points, equals(points));
      expect(renderedPolyline.color, mockOptions.temporaryLineColor);
      expect(renderedPolyline.isDotted, isTrue);
    });
  });
  
  // Interaction with PolyEditor's internal callbacks (onPointAdded, etc.) is hard to test
  // without deeper integration or a more mockable PolyEditor.
  // The primary interaction tested here is the callbackRefresh.
  group('PolyEditor Callbacks', () {
     test('PolyEditor internal changes trigger onRefresh callback', () {
      // Setup an active editing state
      when(mockDrawingState.isMultiPartDrawingInProgress).thenReturn(true);
      when(mockDrawingState.currentDrawingParts).thenReturn([[LatLng(0,0)]]);
      polyEditorManager.reinitializePolyEditorState();
      clearInteractions(mockRefreshCallback);

      // Simulate PolyEditor updating itself (e.g., due to a point drag by user)
      // The .test() method in PolyEditor is designed to call callbackRefresh.
      polyEditorManager.instance?.test();
      verify(mockRefreshCallback()).called(1);
    });
  });

}
